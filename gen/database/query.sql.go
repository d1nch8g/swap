// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package database

import (
	"context"
)

const createCurrency = `-- name: CreateCurrency :one
INSERT INTO currencies (
    code,
    description,
    bestchange_id,
    accepted_window,
    require_payment_verification
  )
VALUES ($1, $2, $3, $4, $5)
RETURNING id, code, description, bestchange_id, accepted_window, require_payment_verification
`

type CreateCurrencyParams struct {
	Code                       string `json:"code"`
	Description                string `json:"description"`
	BestchangeID               string `json:"bestchange_id"`
	AcceptedWindow             string `json:"accepted_window"`
	RequirePaymentVerification bool   `json:"require_payment_verification"`
}

func (q *Queries) CreateCurrency(ctx context.Context, arg CreateCurrencyParams) (Currency, error) {
	row := q.db.QueryRow(ctx, createCurrency,
		arg.Code,
		arg.Description,
		arg.BestchangeID,
		arg.AcceptedWindow,
		arg.RequirePaymentVerification,
	)
	var i Currency
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Description,
		&i.BestchangeID,
		&i.AcceptedWindow,
		&i.RequirePaymentVerification,
	)
	return i, err
}

const createExchanger = `-- name: CreateExchanger :one
INSERT INTO exchangers (
    rate,
    description,
    inmin,
    input,
    output
  )
VALUES ($1, $2, $3, $4, $5)
RETURNING id, rate, inmin, description, input, output
`

type CreateExchangerParams struct {
	Rate        float64 `json:"rate"`
	Description string  `json:"description"`
	Inmin       float64 `json:"inmin"`
	Input       int64   `json:"input"`
	Output      int64   `json:"output"`
}

func (q *Queries) CreateExchanger(ctx context.Context, arg CreateExchangerParams) (Exchanger, error) {
	row := q.db.QueryRow(ctx, createExchanger,
		arg.Rate,
		arg.Description,
		arg.Inmin,
		arg.Input,
		arg.Output,
	)
	var i Exchanger
	err := row.Scan(
		&i.ID,
		&i.Rate,
		&i.Inmin,
		&i.Description,
		&i.Input,
		&i.Output,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    user_id,
    operator_id,
    exchanger_id,
    amount_in,
    amount_out,
    finished
  )
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, operator_id, exchanger_id, amount_in, amount_out, finished
`

type CreateOrderParams struct {
	UserID      int64   `json:"user_id"`
	OperatorID  int64   `json:"operator_id"`
	ExchangerID int64   `json:"exchanger_id"`
	AmountIn    float64 `json:"amount_in"`
	AmountOut   float64 `json:"amount_out"`
	Finished    bool    `json:"finished"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.UserID,
		arg.OperatorID,
		arg.ExchangerID,
		arg.AmountIn,
		arg.AmountOut,
		arg.Finished,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OperatorID,
		&i.ExchangerID,
		&i.AmountIn,
		&i.AmountOut,
		&i.Finished,
	)
	return i, err
}

const createPaymentConfirmation = `-- name: CreatePaymentConfirmation :one
INSERT INTO payment_confirmations (user_id, currency_id, address, verified)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, currency_id, address, verified, image
`

type CreatePaymentConfirmationParams struct {
	UserID     int64  `json:"user_id"`
	CurrencyID int64  `json:"currency_id"`
	Address    string `json:"address"`
	Verified   bool   `json:"verified"`
}

func (q *Queries) CreatePaymentConfirmation(ctx context.Context, arg CreatePaymentConfirmationParams) (PaymentConfirmation, error) {
	row := q.db.QueryRow(ctx, createPaymentConfirmation,
		arg.UserID,
		arg.CurrencyID,
		arg.Address,
		arg.Verified,
	)
	var i PaymentConfirmation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CurrencyID,
		&i.Address,
		&i.Verified,
		&i.Image,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    email,
    verified,
    passwhash,
    token,
    admin,
    busy
  )
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, email, verified, passwhash, admin, token, busy
`

type CreateUserParams struct {
	Email     string `json:"email"`
	Verified  bool   `json:"verified"`
	Passwhash string `json:"passwhash"`
	Token     string `json:"token"`
	Admin     bool   `json:"admin"`
	Busy      bool   `json:"busy"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.Verified,
		arg.Passwhash,
		arg.Token,
		arg.Admin,
		arg.Busy,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Verified,
		&i.Passwhash,
		&i.Admin,
		&i.Token,
		&i.Busy,
	)
	return i, err
}

const createUserBalance = `-- name: CreateUserBalance :one
INSERT INTO user_balances (user_id, currency_id, balance, address)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, currency_id, balance, address
`

type CreateUserBalanceParams struct {
	UserID     int64   `json:"user_id"`
	CurrencyID int64   `json:"currency_id"`
	Balance    float64 `json:"balance"`
	Address    string  `json:"address"`
}

func (q *Queries) CreateUserBalance(ctx context.Context, arg CreateUserBalanceParams) (UserBalance, error) {
	row := q.db.QueryRow(ctx, createUserBalance,
		arg.UserID,
		arg.CurrencyID,
		arg.Balance,
		arg.Address,
	)
	var i UserBalance
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CurrencyID,
		&i.Balance,
		&i.Address,
	)
	return i, err
}

const getCurrencyByCode = `-- name: GetCurrencyByCode :many
SELECT id, code, description, bestchange_id, accepted_window, require_payment_verification
FROM currencies
WHERE code = $1
`

func (q *Queries) GetCurrencyByCode(ctx context.Context, code string) ([]Currency, error) {
	rows, err := q.db.Query(ctx, getCurrencyByCode, code)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Currency
	for rows.Next() {
		var i Currency
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Description,
			&i.BestchangeID,
			&i.AcceptedWindow,
			&i.RequirePaymentVerification,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentConfirmation = `-- name: GetPaymentConfirmation :one
SELECT id, user_id, currency_id, address, verified, image
FROM payment_confirmations
WHERE id = $1
`

func (q *Queries) GetPaymentConfirmation(ctx context.Context, id int64) (PaymentConfirmation, error) {
	row := q.db.QueryRow(ctx, getPaymentConfirmation, id)
	var i PaymentConfirmation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CurrencyID,
		&i.Address,
		&i.Verified,
		&i.Image,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, email, verified, passwhash, admin, token, busy
FROM users
WHERE email = $1
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUser, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Verified,
		&i.Passwhash,
		&i.Admin,
		&i.Token,
		&i.Busy,
	)
	return i, err
}

const getUserByToken = `-- name: GetUserByToken :one
SELECT id, email, verified, passwhash, admin, token, busy
FROM users
WHERE token = $1
`

func (q *Queries) GetUserByToken(ctx context.Context, token string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByToken, token)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Verified,
		&i.Passwhash,
		&i.Admin,
		&i.Token,
		&i.Busy,
	)
	return i, err
}

const listCurrencies = `-- name: ListCurrencies :many
SELECT id, code, description, bestchange_id, accepted_window, require_payment_verification
FROM currencies
`

func (q *Queries) ListCurrencies(ctx context.Context) ([]Currency, error) {
	rows, err := q.db.Query(ctx, listCurrencies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Currency
	for rows.Next() {
		var i Currency
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Description,
			&i.BestchangeID,
			&i.AcceptedWindow,
			&i.RequirePaymentVerification,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, email, verified, passwhash, admin, token, busy
FROM users
ORDER BY email
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Verified,
			&i.Passwhash,
			&i.Admin,
			&i.Token,
			&i.Busy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ordersUnfinished = `-- name: OrdersUnfinished :many
SELECT id, user_id, operator_id, exchanger_id, amount_in, amount_out, finished
FROM orders
WHERE finished = false
`

func (q *Queries) OrdersUnfinished(ctx context.Context) ([]Order, error) {
	rows, err := q.db.Query(ctx, ordersUnfinished)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OperatorID,
			&i.ExchangerID,
			&i.AmountIn,
			&i.AmountOut,
			&i.Finished,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExchangerRate = `-- name: UpdateExchangerRate :one
UPDATE exchangers
set rate = $2
WHERE id = $1
RETURNING id, rate, inmin, description, input, output
`

type UpdateExchangerRateParams struct {
	ID   int64   `json:"id"`
	Rate float64 `json:"rate"`
}

func (q *Queries) UpdateExchangerRate(ctx context.Context, arg UpdateExchangerRateParams) (Exchanger, error) {
	row := q.db.QueryRow(ctx, updateExchangerRate, arg.ID, arg.Rate)
	var i Exchanger
	err := row.Scan(
		&i.ID,
		&i.Rate,
		&i.Inmin,
		&i.Description,
		&i.Input,
		&i.Output,
	)
	return i, err
}

const updatePaymentConfirmationImage = `-- name: UpdatePaymentConfirmationImage :one
UPDATE payment_confirmations
SET image = $2,
  verified = $3
WHERE id = $1
RETURNING id, user_id, currency_id, address, verified, image
`

type UpdatePaymentConfirmationImageParams struct {
	ID       int64  `json:"id"`
	Image    []byte `json:"image"`
	Verified bool   `json:"verified"`
}

func (q *Queries) UpdatePaymentConfirmationImage(ctx context.Context, arg UpdatePaymentConfirmationImageParams) (PaymentConfirmation, error) {
	row := q.db.QueryRow(ctx, updatePaymentConfirmationImage, arg.ID, arg.Image, arg.Verified)
	var i PaymentConfirmation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CurrencyID,
		&i.Address,
		&i.Verified,
		&i.Image,
	)
	return i, err
}

const updateUserBalance = `-- name: UpdateUserBalance :one
UPDATE user_balances
SET balance = $2
WHERE id = $1
RETURNING id, user_id, currency_id, balance, address
`

type UpdateUserBalanceParams struct {
	ID      int64   `json:"id"`
	Balance float64 `json:"balance"`
}

func (q *Queries) UpdateUserBalance(ctx context.Context, arg UpdateUserBalanceParams) (UserBalance, error) {
	row := q.db.QueryRow(ctx, updateUserBalance, arg.ID, arg.Balance)
	var i UserBalance
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CurrencyID,
		&i.Balance,
		&i.Address,
	)
	return i, err
}

const updateUserBusy = `-- name: UpdateUserBusy :one
UPDATE users
SET busy = $2
WHERE email = $1
RETURNING id, email, verified, passwhash, admin, token, busy
`

type UpdateUserBusyParams struct {
	Email string `json:"email"`
	Busy  bool   `json:"busy"`
}

func (q *Queries) UpdateUserBusy(ctx context.Context, arg UpdateUserBusyParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserBusy, arg.Email, arg.Busy)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Verified,
		&i.Passwhash,
		&i.Admin,
		&i.Token,
		&i.Busy,
	)
	return i, err
}

const updateUserToken = `-- name: UpdateUserToken :one
UPDATE users
SET token = $2
WHERE id = $1
RETURNING id, email, verified, passwhash, admin, token, busy
`

type UpdateUserTokenParams struct {
	ID    int64  `json:"id"`
	Token string `json:"token"`
}

func (q *Queries) UpdateUserToken(ctx context.Context, arg UpdateUserTokenParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserToken, arg.ID, arg.Token)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Verified,
		&i.Passwhash,
		&i.Admin,
		&i.Token,
		&i.Busy,
	)
	return i, err
}

const updateUserVerified = `-- name: UpdateUserVerified :one
UPDATE users
SET verified = $2
WHERE email = $1
RETURNING id, email, verified, passwhash, admin, token, busy
`

type UpdateUserVerifiedParams struct {
	Email    string `json:"email"`
	Verified bool   `json:"verified"`
}

func (q *Queries) UpdateUserVerified(ctx context.Context, arg UpdateUserVerifiedParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserVerified, arg.Email, arg.Verified)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Verified,
		&i.Passwhash,
		&i.Admin,
		&i.Token,
		&i.Busy,
	)
	return i, err
}
